// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NEUTRALDATA_FOUNDRY_H_
#define FLATBUFFERS_GENERATED_NEUTRALDATA_FOUNDRY_H_

#include "flatbuffers/flatbuffers.h"

namespace Foundry {

struct Vec3;

struct MeshData;

struct CameraData;

struct LightData;

struct TextureData;

struct NodeData;

struct TextureEffect;

struct MaterialData;

struct ConfigData;

enum ELightType {
  ELightType_eSpot = 0,
  ELightType_eDirectional = 1,
  ELightType_ePoint = 2,
  ELightType_eArea = 3,
  ELightType_eUndefined = 4,
  ELightType_eMaxLightType = 5,
  ELightType_MIN = ELightType_eSpot,
  ELightType_MAX = ELightType_eMaxLightType
};

inline const char **EnumNamesELightType() {
  static const char *names[] = {
    "eSpot",
    "eDirectional",
    "ePoint",
    "eArea",
    "eUndefined",
    "eMaxLightType",
    nullptr
  };
  return names;
}

inline const char *EnumNameELightType(ELightType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesELightType()[index];
}

enum ETextureComponents {
  ETextureComponents_eInvalid = 0,
  ETextureComponents_eR = 1,
  ETextureComponents_eRGB = 3,
  ETextureComponents_eRGBA = 4,
  ETextureComponents_MIN = ETextureComponents_eInvalid,
  ETextureComponents_MAX = ETextureComponents_eRGBA
};

inline const char **EnumNamesETextureComponents() {
  static const char *names[] = {
    "eInvalid",
    "eR",
    "",
    "eRGB",
    "eRGBA",
    nullptr
  };
  return names;
}

inline const char *EnumNameETextureComponents(ETextureComponents e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesETextureComponents()[index];
}

enum ETextureFormat {
  ETextureFormat_eChar = 0,
  ETextureFormat_eFloat = 1,
  ETextureFormat_MIN = ETextureFormat_eChar,
  ETextureFormat_MAX = ETextureFormat_eFloat
};

inline const char **EnumNamesETextureFormat() {
  static const char *names[] = {
    "eChar",
    "eFloat",
    nullptr
  };
  return names;
}

inline const char *EnumNameETextureFormat(ETextureFormat e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesETextureFormat()[index];
}

enum ETextureColorCorrection {
  ETextureColorCorrection_eSRGB = 0,
  ETextureColorCorrection_eLinear = 1,
  ETextureColorCorrection_MIN = ETextureColorCorrection_eSRGB,
  ETextureColorCorrection_MAX = ETextureColorCorrection_eLinear
};

inline const char **EnumNamesETextureColorCorrection() {
  static const char *names[] = {
    "eSRGB",
    "eLinear",
    nullptr
  };
  return names;
}

inline const char *EnumNameETextureColorCorrection(ETextureColorCorrection e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesETextureColorCorrection()[index];
}

enum ETextureSwizzle {
  ETextureSwizzle_eRGB = 0,
  ETextureSwizzle_eRGBA = 1,
  ETextureSwizzle_eAAA = 2,
  ETextureSwizzle_eRRR = 3,
  ETextureSwizzle_eGGG = 4,
  ETextureSwizzle_eBBB = 5,
  ETextureSwizzle_MIN = ETextureSwizzle_eRGB,
  ETextureSwizzle_MAX = ETextureSwizzle_eBBB
};

inline const char **EnumNamesETextureSwizzle() {
  static const char *names[] = {
    "eRGB",
    "eRGBA",
    "eAAA",
    "eRRR",
    "eGGG",
    "eBBB",
    nullptr
  };
  return names;
}

inline const char *EnumNameETextureSwizzle(ETextureSwizzle e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesETextureSwizzle()[index];
}

enum EMaterialSlot {
  EMaterialSlot_eAmbientOcclusion = 0,
  EMaterialSlot_eBaseColor = 1,
  EMaterialSlot_eClearCoatAmt = 2,
  EMaterialSlot_eClearCoatRough = 3,
  EMaterialSlot_eBump = 4,
  EMaterialSlot_eNormal = 5,
  EMaterialSlot_eMetallic = 6,
  EMaterialSlot_eEmissiveColor = 7,
  EMaterialSlot_eOpacity = 8,
  EMaterialSlot_eRoughness = 9,
  EMaterialSlot_eSpecular = 10,
  EMaterialSlot_eSubsurfaceColor = 11,
  EMaterialSlot_MIN = EMaterialSlot_eAmbientOcclusion,
  EMaterialSlot_MAX = EMaterialSlot_eSubsurfaceColor
};

inline const char **EnumNamesEMaterialSlot() {
  static const char *names[] = {
    "eAmbientOcclusion",
    "eBaseColor",
    "eClearCoatAmt",
    "eClearCoatRough",
    "eBump",
    "eNormal",
    "eMetallic",
    "eEmissiveColor",
    "eOpacity",
    "eRoughness",
    "eSpecular",
    "eSubsurfaceColor",
    nullptr
  };
  return names;
}

inline const char *EnumNameEMaterialSlot(EMaterialSlot e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEMaterialSlot()[index];
}

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(const Vec3 &_o) {
    memcpy(this, &_o, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vec3, 12);

MANUALLY_ALIGNED_STRUCT(4) TextureEffect FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t uvIndex_;
  float wrapU_;
  float wrapV_;
  int8_t swizzle_;
  int8_t padding0__;  int16_t padding1__;
  float R_;
  float G_;
  float B_;

 public:
  TextureEffect() {
    memset(this, 0, sizeof(TextureEffect));
  }
  TextureEffect(const TextureEffect &_o) {
    memcpy(this, &_o, sizeof(TextureEffect));
  }
  TextureEffect(uint32_t _uvIndex, float _wrapU, float _wrapV, ETextureSwizzle _swizzle, float _R, float _G, float _B)
      : uvIndex_(flatbuffers::EndianScalar(_uvIndex)),
        wrapU_(flatbuffers::EndianScalar(_wrapU)),
        wrapV_(flatbuffers::EndianScalar(_wrapV)),
        swizzle_(flatbuffers::EndianScalar(static_cast<int8_t>(_swizzle))),
        padding0__(0),
        padding1__(0),
        R_(flatbuffers::EndianScalar(_R)),
        G_(flatbuffers::EndianScalar(_G)),
        B_(flatbuffers::EndianScalar(_B)) {
    (void)padding0__;    (void)padding1__;
  }
  uint32_t uvIndex() const {
    return flatbuffers::EndianScalar(uvIndex_);
  }
  float wrapU() const {
    return flatbuffers::EndianScalar(wrapU_);
  }
  float wrapV() const {
    return flatbuffers::EndianScalar(wrapV_);
  }
  ETextureSwizzle swizzle() const {
    return static_cast<ETextureSwizzle>(flatbuffers::EndianScalar(swizzle_));
  }
  float R() const {
    return flatbuffers::EndianScalar(R_);
  }
  float G() const {
    return flatbuffers::EndianScalar(G_);
  }
  float B() const {
    return flatbuffers::EndianScalar(B_);
  }
};
STRUCT_END(TextureEffect, 28);

struct MeshData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UNIQUENAME = 4,
    VT_DISPLAYNAME = 6,
    VT_INDICES = 8,
    VT_VERTICES = 10,
    VT_NORMALS = 12,
    VT_UVS = 14,
    VT_COLORS = 16,
    VT_TANGENTS = 18,
    VT_MATINDICES = 20,
    VT_MATERIALNAMES = 22
  };
  const flatbuffers::String *uniqueName() const {
    return GetPointer<const flatbuffers::String *>(VT_UNIQUENAME);
  }
  const flatbuffers::String *displayName() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAYNAME);
  }
  const flatbuffers::Vector<uint32_t> *indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INDICES);
  }
  const flatbuffers::Vector<float> *vertices() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VERTICES);
  }
  const flatbuffers::Vector<float> *normals() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_NORMALS);
  }
  const flatbuffers::Vector<float> *uvs() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_UVS);
  }
  const flatbuffers::Vector<float> *colors() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_COLORS);
  }
  const flatbuffers::Vector<float> *tangents() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_TANGENTS);
  }
  const flatbuffers::Vector<uint32_t> *matIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_MATINDICES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *materialNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MATERIALNAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNIQUENAME) &&
           verifier.Verify(uniqueName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DISPLAYNAME) &&
           verifier.Verify(displayName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_INDICES) &&
           verifier.Verify(indices()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VERTICES) &&
           verifier.Verify(vertices()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NORMALS) &&
           verifier.Verify(normals()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UVS) &&
           verifier.Verify(uvs()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COLORS) &&
           verifier.Verify(colors()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TANGENTS) &&
           verifier.Verify(tangents()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MATINDICES) &&
           verifier.Verify(matIndices()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MATERIALNAMES) &&
           verifier.Verify(materialNames()) &&
           verifier.VerifyVectorOfStrings(materialNames()) &&
           verifier.EndTable();
  }
};

struct MeshDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uniqueName(flatbuffers::Offset<flatbuffers::String> uniqueName) {
    fbb_.AddOffset(MeshData::VT_UNIQUENAME, uniqueName);
  }
  void add_displayName(flatbuffers::Offset<flatbuffers::String> displayName) {
    fbb_.AddOffset(MeshData::VT_DISPLAYNAME, displayName);
  }
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> indices) {
    fbb_.AddOffset(MeshData::VT_INDICES, indices);
  }
  void add_vertices(flatbuffers::Offset<flatbuffers::Vector<float>> vertices) {
    fbb_.AddOffset(MeshData::VT_VERTICES, vertices);
  }
  void add_normals(flatbuffers::Offset<flatbuffers::Vector<float>> normals) {
    fbb_.AddOffset(MeshData::VT_NORMALS, normals);
  }
  void add_uvs(flatbuffers::Offset<flatbuffers::Vector<float>> uvs) {
    fbb_.AddOffset(MeshData::VT_UVS, uvs);
  }
  void add_colors(flatbuffers::Offset<flatbuffers::Vector<float>> colors) {
    fbb_.AddOffset(MeshData::VT_COLORS, colors);
  }
  void add_tangents(flatbuffers::Offset<flatbuffers::Vector<float>> tangents) {
    fbb_.AddOffset(MeshData::VT_TANGENTS, tangents);
  }
  void add_matIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> matIndices) {
    fbb_.AddOffset(MeshData::VT_MATINDICES, matIndices);
  }
  void add_materialNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materialNames) {
    fbb_.AddOffset(MeshData::VT_MATERIALNAMES, materialNames);
  }
  MeshDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshDataBuilder &operator=(const MeshDataBuilder &);
  flatbuffers::Offset<MeshData> Finish() {
    const auto end = fbb_.EndTable(start_, 10);
    auto o = flatbuffers::Offset<MeshData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshData> CreateMeshData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uniqueName = 0,
    flatbuffers::Offset<flatbuffers::String> displayName = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> vertices = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> normals = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> uvs = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> colors = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> tangents = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> matIndices = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materialNames = 0) {
  MeshDataBuilder builder_(_fbb);
  builder_.add_materialNames(materialNames);
  builder_.add_matIndices(matIndices);
  builder_.add_tangents(tangents);
  builder_.add_colors(colors);
  builder_.add_uvs(uvs);
  builder_.add_normals(normals);
  builder_.add_vertices(vertices);
  builder_.add_indices(indices);
  builder_.add_displayName(displayName);
  builder_.add_uniqueName(uniqueName);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeshData> CreateMeshDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uniqueName = nullptr,
    const char *displayName = nullptr,
    const std::vector<uint32_t> *indices = nullptr,
    const std::vector<float> *vertices = nullptr,
    const std::vector<float> *normals = nullptr,
    const std::vector<float> *uvs = nullptr,
    const std::vector<float> *colors = nullptr,
    const std::vector<float> *tangents = nullptr,
    const std::vector<uint32_t> *matIndices = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *materialNames = nullptr) {
  return Foundry::CreateMeshData(
      _fbb,
      uniqueName ? _fbb.CreateString(uniqueName) : 0,
      displayName ? _fbb.CreateString(displayName) : 0,
      indices ? _fbb.CreateVector<uint32_t>(*indices) : 0,
      vertices ? _fbb.CreateVector<float>(*vertices) : 0,
      normals ? _fbb.CreateVector<float>(*normals) : 0,
      uvs ? _fbb.CreateVector<float>(*uvs) : 0,
      colors ? _fbb.CreateVector<float>(*colors) : 0,
      tangents ? _fbb.CreateVector<float>(*tangents) : 0,
      matIndices ? _fbb.CreateVector<uint32_t>(*matIndices) : 0,
      materialNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*materialNames) : 0);
}

struct CameraData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UNIQUENAME = 4,
    VT_DISPLAYNAME = 6,
    VT_POSITION = 8,
    VT_LOOKAT = 10,
    VT_UP = 12,
    VT_ASPECT = 14,
    VT_HORIZONTALFOV = 16,
    VT_CLIPPLANENEAR = 18,
    VT_CLIPPLANEFAR = 20
  };
  const flatbuffers::String *uniqueName() const {
    return GetPointer<const flatbuffers::String *>(VT_UNIQUENAME);
  }
  const flatbuffers::String *displayName() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAYNAME);
  }
  const Vec3 *position() const {
    return GetStruct<const Vec3 *>(VT_POSITION);
  }
  const Vec3 *lookAt() const {
    return GetStruct<const Vec3 *>(VT_LOOKAT);
  }
  const Vec3 *up() const {
    return GetStruct<const Vec3 *>(VT_UP);
  }
  float aspect() const {
    return GetField<float>(VT_ASPECT, 0.0f);
  }
  float horizontalFOV() const {
    return GetField<float>(VT_HORIZONTALFOV, 0.0f);
  }
  float clipPlaneNear() const {
    return GetField<float>(VT_CLIPPLANENEAR, 0.0f);
  }
  float clipPlaneFar() const {
    return GetField<float>(VT_CLIPPLANEFAR, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNIQUENAME) &&
           verifier.Verify(uniqueName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DISPLAYNAME) &&
           verifier.Verify(displayName()) &&
           VerifyField<Vec3>(verifier, VT_POSITION) &&
           VerifyField<Vec3>(verifier, VT_LOOKAT) &&
           VerifyField<Vec3>(verifier, VT_UP) &&
           VerifyField<float>(verifier, VT_ASPECT) &&
           VerifyField<float>(verifier, VT_HORIZONTALFOV) &&
           VerifyField<float>(verifier, VT_CLIPPLANENEAR) &&
           VerifyField<float>(verifier, VT_CLIPPLANEFAR) &&
           verifier.EndTable();
  }
};

struct CameraDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uniqueName(flatbuffers::Offset<flatbuffers::String> uniqueName) {
    fbb_.AddOffset(CameraData::VT_UNIQUENAME, uniqueName);
  }
  void add_displayName(flatbuffers::Offset<flatbuffers::String> displayName) {
    fbb_.AddOffset(CameraData::VT_DISPLAYNAME, displayName);
  }
  void add_position(const Vec3 *position) {
    fbb_.AddStruct(CameraData::VT_POSITION, position);
  }
  void add_lookAt(const Vec3 *lookAt) {
    fbb_.AddStruct(CameraData::VT_LOOKAT, lookAt);
  }
  void add_up(const Vec3 *up) {
    fbb_.AddStruct(CameraData::VT_UP, up);
  }
  void add_aspect(float aspect) {
    fbb_.AddElement<float>(CameraData::VT_ASPECT, aspect, 0.0f);
  }
  void add_horizontalFOV(float horizontalFOV) {
    fbb_.AddElement<float>(CameraData::VT_HORIZONTALFOV, horizontalFOV, 0.0f);
  }
  void add_clipPlaneNear(float clipPlaneNear) {
    fbb_.AddElement<float>(CameraData::VT_CLIPPLANENEAR, clipPlaneNear, 0.0f);
  }
  void add_clipPlaneFar(float clipPlaneFar) {
    fbb_.AddElement<float>(CameraData::VT_CLIPPLANEFAR, clipPlaneFar, 0.0f);
  }
  CameraDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CameraDataBuilder &operator=(const CameraDataBuilder &);
  flatbuffers::Offset<CameraData> Finish() {
    const auto end = fbb_.EndTable(start_, 9);
    auto o = flatbuffers::Offset<CameraData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CameraData> CreateCameraData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uniqueName = 0,
    flatbuffers::Offset<flatbuffers::String> displayName = 0,
    const Vec3 *position = 0,
    const Vec3 *lookAt = 0,
    const Vec3 *up = 0,
    float aspect = 0.0f,
    float horizontalFOV = 0.0f,
    float clipPlaneNear = 0.0f,
    float clipPlaneFar = 0.0f) {
  CameraDataBuilder builder_(_fbb);
  builder_.add_clipPlaneFar(clipPlaneFar);
  builder_.add_clipPlaneNear(clipPlaneNear);
  builder_.add_horizontalFOV(horizontalFOV);
  builder_.add_aspect(aspect);
  builder_.add_up(up);
  builder_.add_lookAt(lookAt);
  builder_.add_position(position);
  builder_.add_displayName(displayName);
  builder_.add_uniqueName(uniqueName);
  return builder_.Finish();
}

inline flatbuffers::Offset<CameraData> CreateCameraDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uniqueName = nullptr,
    const char *displayName = nullptr,
    const Vec3 *position = 0,
    const Vec3 *lookAt = 0,
    const Vec3 *up = 0,
    float aspect = 0.0f,
    float horizontalFOV = 0.0f,
    float clipPlaneNear = 0.0f,
    float clipPlaneFar = 0.0f) {
  return Foundry::CreateCameraData(
      _fbb,
      uniqueName ? _fbb.CreateString(uniqueName) : 0,
      displayName ? _fbb.CreateString(displayName) : 0,
      position,
      lookAt,
      up,
      aspect,
      horizontalFOV,
      clipPlaneNear,
      clipPlaneFar);
}

struct LightData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UNIQUENAME = 4,
    VT_DISPLAYNAME = 6,
    VT_ANGLEINNERCONE = 8,
    VT_ANGLEOUTERCONE = 10,
    VT_ATTENUATIONCONSTANT = 12,
    VT_ATTENUATIONLINEAR = 14,
    VT_ATTENUATIONQUADRATIC = 16,
    VT_INTENSITY = 18,
    VT_AMBIENT = 20,
    VT_DIFFUSE = 22,
    VT_SPECULAR = 24,
    VT_DIRECTION = 26,
    VT_POSITION = 28,
    VT_TYPE = 30
  };
  const flatbuffers::String *uniqueName() const {
    return GetPointer<const flatbuffers::String *>(VT_UNIQUENAME);
  }
  const flatbuffers::String *displayName() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAYNAME);
  }
  float angleInnerCone() const {
    return GetField<float>(VT_ANGLEINNERCONE, 0.0f);
  }
  float angleOuterCone() const {
    return GetField<float>(VT_ANGLEOUTERCONE, 0.0f);
  }
  float attenuationConstant() const {
    return GetField<float>(VT_ATTENUATIONCONSTANT, 0.0f);
  }
  float attenuationLinear() const {
    return GetField<float>(VT_ATTENUATIONLINEAR, 0.0f);
  }
  float attenuationQuadratic() const {
    return GetField<float>(VT_ATTENUATIONQUADRATIC, 0.0f);
  }
  float intensity() const {
    return GetField<float>(VT_INTENSITY, 0.0f);
  }
  const Vec3 *ambient() const {
    return GetStruct<const Vec3 *>(VT_AMBIENT);
  }
  const Vec3 *diffuse() const {
    return GetStruct<const Vec3 *>(VT_DIFFUSE);
  }
  const Vec3 *specular() const {
    return GetStruct<const Vec3 *>(VT_SPECULAR);
  }
  const Vec3 *direction() const {
    return GetStruct<const Vec3 *>(VT_DIRECTION);
  }
  const Vec3 *position() const {
    return GetStruct<const Vec3 *>(VT_POSITION);
  }
  ELightType type() const {
    return static_cast<ELightType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNIQUENAME) &&
           verifier.Verify(uniqueName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DISPLAYNAME) &&
           verifier.Verify(displayName()) &&
           VerifyField<float>(verifier, VT_ANGLEINNERCONE) &&
           VerifyField<float>(verifier, VT_ANGLEOUTERCONE) &&
           VerifyField<float>(verifier, VT_ATTENUATIONCONSTANT) &&
           VerifyField<float>(verifier, VT_ATTENUATIONLINEAR) &&
           VerifyField<float>(verifier, VT_ATTENUATIONQUADRATIC) &&
           VerifyField<float>(verifier, VT_INTENSITY) &&
           VerifyField<Vec3>(verifier, VT_AMBIENT) &&
           VerifyField<Vec3>(verifier, VT_DIFFUSE) &&
           VerifyField<Vec3>(verifier, VT_SPECULAR) &&
           VerifyField<Vec3>(verifier, VT_DIRECTION) &&
           VerifyField<Vec3>(verifier, VT_POSITION) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct LightDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uniqueName(flatbuffers::Offset<flatbuffers::String> uniqueName) {
    fbb_.AddOffset(LightData::VT_UNIQUENAME, uniqueName);
  }
  void add_displayName(flatbuffers::Offset<flatbuffers::String> displayName) {
    fbb_.AddOffset(LightData::VT_DISPLAYNAME, displayName);
  }
  void add_angleInnerCone(float angleInnerCone) {
    fbb_.AddElement<float>(LightData::VT_ANGLEINNERCONE, angleInnerCone, 0.0f);
  }
  void add_angleOuterCone(float angleOuterCone) {
    fbb_.AddElement<float>(LightData::VT_ANGLEOUTERCONE, angleOuterCone, 0.0f);
  }
  void add_attenuationConstant(float attenuationConstant) {
    fbb_.AddElement<float>(LightData::VT_ATTENUATIONCONSTANT, attenuationConstant, 0.0f);
  }
  void add_attenuationLinear(float attenuationLinear) {
    fbb_.AddElement<float>(LightData::VT_ATTENUATIONLINEAR, attenuationLinear, 0.0f);
  }
  void add_attenuationQuadratic(float attenuationQuadratic) {
    fbb_.AddElement<float>(LightData::VT_ATTENUATIONQUADRATIC, attenuationQuadratic, 0.0f);
  }
  void add_intensity(float intensity) {
    fbb_.AddElement<float>(LightData::VT_INTENSITY, intensity, 0.0f);
  }
  void add_ambient(const Vec3 *ambient) {
    fbb_.AddStruct(LightData::VT_AMBIENT, ambient);
  }
  void add_diffuse(const Vec3 *diffuse) {
    fbb_.AddStruct(LightData::VT_DIFFUSE, diffuse);
  }
  void add_specular(const Vec3 *specular) {
    fbb_.AddStruct(LightData::VT_SPECULAR, specular);
  }
  void add_direction(const Vec3 *direction) {
    fbb_.AddStruct(LightData::VT_DIRECTION, direction);
  }
  void add_position(const Vec3 *position) {
    fbb_.AddStruct(LightData::VT_POSITION, position);
  }
  void add_type(ELightType type) {
    fbb_.AddElement<int8_t>(LightData::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  LightDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LightDataBuilder &operator=(const LightDataBuilder &);
  flatbuffers::Offset<LightData> Finish() {
    const auto end = fbb_.EndTable(start_, 14);
    auto o = flatbuffers::Offset<LightData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LightData> CreateLightData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uniqueName = 0,
    flatbuffers::Offset<flatbuffers::String> displayName = 0,
    float angleInnerCone = 0.0f,
    float angleOuterCone = 0.0f,
    float attenuationConstant = 0.0f,
    float attenuationLinear = 0.0f,
    float attenuationQuadratic = 0.0f,
    float intensity = 0.0f,
    const Vec3 *ambient = 0,
    const Vec3 *diffuse = 0,
    const Vec3 *specular = 0,
    const Vec3 *direction = 0,
    const Vec3 *position = 0,
    ELightType type = ELightType_eSpot) {
  LightDataBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_direction(direction);
  builder_.add_specular(specular);
  builder_.add_diffuse(diffuse);
  builder_.add_ambient(ambient);
  builder_.add_intensity(intensity);
  builder_.add_attenuationQuadratic(attenuationQuadratic);
  builder_.add_attenuationLinear(attenuationLinear);
  builder_.add_attenuationConstant(attenuationConstant);
  builder_.add_angleOuterCone(angleOuterCone);
  builder_.add_angleInnerCone(angleInnerCone);
  builder_.add_displayName(displayName);
  builder_.add_uniqueName(uniqueName);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<LightData> CreateLightDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uniqueName = nullptr,
    const char *displayName = nullptr,
    float angleInnerCone = 0.0f,
    float angleOuterCone = 0.0f,
    float attenuationConstant = 0.0f,
    float attenuationLinear = 0.0f,
    float attenuationQuadratic = 0.0f,
    float intensity = 0.0f,
    const Vec3 *ambient = 0,
    const Vec3 *diffuse = 0,
    const Vec3 *specular = 0,
    const Vec3 *direction = 0,
    const Vec3 *position = 0,
    ELightType type = ELightType_eSpot) {
  return Foundry::CreateLightData(
      _fbb,
      uniqueName ? _fbb.CreateString(uniqueName) : 0,
      displayName ? _fbb.CreateString(displayName) : 0,
      angleInnerCone,
      angleOuterCone,
      attenuationConstant,
      attenuationLinear,
      attenuationQuadratic,
      intensity,
      ambient,
      diffuse,
      specular,
      direction,
      position,
      type);
}

struct TextureData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UNIQUENAME = 4,
    VT_DISPLAYNAME = 6,
    VT_HEIGHT = 8,
    VT_WIDTH = 10,
    VT_FORMAT = 12,
    VT_COMPONENTS = 14,
    VT_COLORCORRECTION = 16,
    VT_COLORS = 18,
    VT_FCOLORS = 20
  };
  const flatbuffers::String *uniqueName() const {
    return GetPointer<const flatbuffers::String *>(VT_UNIQUENAME);
  }
  const flatbuffers::String *displayName() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAYNAME);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  ETextureFormat format() const {
    return static_cast<ETextureFormat>(GetField<int8_t>(VT_FORMAT, 0));
  }
  ETextureComponents components() const {
    return static_cast<ETextureComponents>(GetField<int8_t>(VT_COMPONENTS, 0));
  }
  ETextureColorCorrection colorCorrection() const {
    return static_cast<ETextureColorCorrection>(GetField<int8_t>(VT_COLORCORRECTION, 0));
  }
  const flatbuffers::Vector<uint8_t> *colors() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_COLORS);
  }
  const flatbuffers::Vector<float> *fcolors() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FCOLORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNIQUENAME) &&
           verifier.Verify(uniqueName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DISPLAYNAME) &&
           verifier.Verify(displayName()) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<int8_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_COMPONENTS) &&
           VerifyField<int8_t>(verifier, VT_COLORCORRECTION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COLORS) &&
           verifier.Verify(colors()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FCOLORS) &&
           verifier.Verify(fcolors()) &&
           verifier.EndTable();
  }
};

struct TextureDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uniqueName(flatbuffers::Offset<flatbuffers::String> uniqueName) {
    fbb_.AddOffset(TextureData::VT_UNIQUENAME, uniqueName);
  }
  void add_displayName(flatbuffers::Offset<flatbuffers::String> displayName) {
    fbb_.AddOffset(TextureData::VT_DISPLAYNAME, displayName);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(TextureData::VT_HEIGHT, height, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(TextureData::VT_WIDTH, width, 0);
  }
  void add_format(ETextureFormat format) {
    fbb_.AddElement<int8_t>(TextureData::VT_FORMAT, static_cast<int8_t>(format), 0);
  }
  void add_components(ETextureComponents components) {
    fbb_.AddElement<int8_t>(TextureData::VT_COMPONENTS, static_cast<int8_t>(components), 0);
  }
  void add_colorCorrection(ETextureColorCorrection colorCorrection) {
    fbb_.AddElement<int8_t>(TextureData::VT_COLORCORRECTION, static_cast<int8_t>(colorCorrection), 0);
  }
  void add_colors(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> colors) {
    fbb_.AddOffset(TextureData::VT_COLORS, colors);
  }
  void add_fcolors(flatbuffers::Offset<flatbuffers::Vector<float>> fcolors) {
    fbb_.AddOffset(TextureData::VT_FCOLORS, fcolors);
  }
  TextureDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureDataBuilder &operator=(const TextureDataBuilder &);
  flatbuffers::Offset<TextureData> Finish() {
    const auto end = fbb_.EndTable(start_, 9);
    auto o = flatbuffers::Offset<TextureData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureData> CreateTextureData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uniqueName = 0,
    flatbuffers::Offset<flatbuffers::String> displayName = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    ETextureFormat format = ETextureFormat_eChar,
    ETextureComponents components = ETextureComponents_eInvalid,
    ETextureColorCorrection colorCorrection = ETextureColorCorrection_eSRGB,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> colors = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> fcolors = 0) {
  TextureDataBuilder builder_(_fbb);
  builder_.add_fcolors(fcolors);
  builder_.add_colors(colors);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_displayName(displayName);
  builder_.add_uniqueName(uniqueName);
  builder_.add_colorCorrection(colorCorrection);
  builder_.add_components(components);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextureData> CreateTextureDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uniqueName = nullptr,
    const char *displayName = nullptr,
    uint32_t height = 0,
    uint32_t width = 0,
    ETextureFormat format = ETextureFormat_eChar,
    ETextureComponents components = ETextureComponents_eInvalid,
    ETextureColorCorrection colorCorrection = ETextureColorCorrection_eSRGB,
    const std::vector<uint8_t> *colors = nullptr,
    const std::vector<float> *fcolors = nullptr) {
  return Foundry::CreateTextureData(
      _fbb,
      uniqueName ? _fbb.CreateString(uniqueName) : 0,
      displayName ? _fbb.CreateString(displayName) : 0,
      height,
      width,
      format,
      components,
      colorCorrection,
      colors ? _fbb.CreateVector<uint8_t>(*colors) : 0,
      fcolors ? _fbb.CreateVector<float>(*fcolors) : 0);
}

struct NodeData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UNIQUENAME = 4,
    VT_DISPLAYNAME = 6,
    VT_TRANSFORMATION = 8,
    VT_MESHES = 10,
    VT_CAMERAS = 12,
    VT_LIGHTS = 14,
    VT_CHILDREN = 16,
    VT_MATERIALOVERRIDENAMES = 18
  };
  const flatbuffers::String *uniqueName() const {
    return GetPointer<const flatbuffers::String *>(VT_UNIQUENAME);
  }
  const flatbuffers::String *displayName() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAYNAME);
  }
  const flatbuffers::Vector<float> *transformation() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_TRANSFORMATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *meshes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MESHES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *cameras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CAMERAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *lights() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LIGHTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *children() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CHILDREN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *materialOverrideNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MATERIALOVERRIDENAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNIQUENAME) &&
           verifier.Verify(uniqueName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DISPLAYNAME) &&
           verifier.Verify(displayName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TRANSFORMATION) &&
           verifier.Verify(transformation()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESHES) &&
           verifier.Verify(meshes()) &&
           verifier.VerifyVectorOfStrings(meshes()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CAMERAS) &&
           verifier.Verify(cameras()) &&
           verifier.VerifyVectorOfStrings(cameras()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LIGHTS) &&
           verifier.Verify(lights()) &&
           verifier.VerifyVectorOfStrings(lights()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfStrings(children()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MATERIALOVERRIDENAMES) &&
           verifier.Verify(materialOverrideNames()) &&
           verifier.VerifyVectorOfStrings(materialOverrideNames()) &&
           verifier.EndTable();
  }
};

struct NodeDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uniqueName(flatbuffers::Offset<flatbuffers::String> uniqueName) {
    fbb_.AddOffset(NodeData::VT_UNIQUENAME, uniqueName);
  }
  void add_displayName(flatbuffers::Offset<flatbuffers::String> displayName) {
    fbb_.AddOffset(NodeData::VT_DISPLAYNAME, displayName);
  }
  void add_transformation(flatbuffers::Offset<flatbuffers::Vector<float>> transformation) {
    fbb_.AddOffset(NodeData::VT_TRANSFORMATION, transformation);
  }
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> meshes) {
    fbb_.AddOffset(NodeData::VT_MESHES, meshes);
  }
  void add_cameras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> cameras) {
    fbb_.AddOffset(NodeData::VT_CAMERAS, cameras);
  }
  void add_lights(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> lights) {
    fbb_.AddOffset(NodeData::VT_LIGHTS, lights);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> children) {
    fbb_.AddOffset(NodeData::VT_CHILDREN, children);
  }
  void add_materialOverrideNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materialOverrideNames) {
    fbb_.AddOffset(NodeData::VT_MATERIALOVERRIDENAMES, materialOverrideNames);
  }
  NodeDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeDataBuilder &operator=(const NodeDataBuilder &);
  flatbuffers::Offset<NodeData> Finish() {
    const auto end = fbb_.EndTable(start_, 8);
    auto o = flatbuffers::Offset<NodeData>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeData> CreateNodeData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uniqueName = 0,
    flatbuffers::Offset<flatbuffers::String> displayName = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> transformation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> meshes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> cameras = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> lights = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> children = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materialOverrideNames = 0) {
  NodeDataBuilder builder_(_fbb);
  builder_.add_materialOverrideNames(materialOverrideNames);
  builder_.add_children(children);
  builder_.add_lights(lights);
  builder_.add_cameras(cameras);
  builder_.add_meshes(meshes);
  builder_.add_transformation(transformation);
  builder_.add_displayName(displayName);
  builder_.add_uniqueName(uniqueName);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeData> CreateNodeDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uniqueName = nullptr,
    const char *displayName = nullptr,
    const std::vector<float> *transformation = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *meshes = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *cameras = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *lights = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *children = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *materialOverrideNames = nullptr) {
  return Foundry::CreateNodeData(
      _fbb,
      uniqueName ? _fbb.CreateString(uniqueName) : 0,
      displayName ? _fbb.CreateString(displayName) : 0,
      transformation ? _fbb.CreateVector<float>(*transformation) : 0,
      meshes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*meshes) : 0,
      cameras ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*cameras) : 0,
      lights ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*lights) : 0,
      children ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*children) : 0,
      materialOverrideNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*materialOverrideNames) : 0);
}

struct MaterialData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UNIQUENAME = 4,
    VT_DISPLAYNAME = 6,
    VT_AMBIENTOCCLUSION = 8,
    VT_AMBIENTOCCLUSIONIMGNAME = 10,
    VT_BASECOLOR = 12,
    VT_BASECOLORIMGNAME = 14,
    VT_CLEARCOATAMT = 16,
    VT_CLEARCOATAMTIMGNAME = 18,
    VT_CLEARCOATROUGH = 20,
    VT_CLEARCOATROUGHIMGNAME = 22,
    VT_BUMP = 24,
    VT_BUMPIMGNAME = 26,
    VT_NORMAL = 28,
    VT_NORMALIMGNAME = 30,
    VT_METALLIC = 32,
    VT_METALLICIMGNAME = 34,
    VT_EMISSIVECOLOR = 36,
    VT_EMISSIVECOLORIMGNAME = 38,
    VT_OPACITY = 40,
    VT_OPACITYIMGNAME = 42,
    VT_ROUGHNESS = 44,
    VT_ROUGHNESSIMGNAME = 46,
    VT_SPECULAR = 48,
    VT_SPECULARIMGNAME = 50,
    VT_SUBSURFACECOLOR = 52,
    VT_SUBSURFACECOLORIMGNAME = 54,
    VT_UNKNOWN = 56,
    VT_UNKNOWNIMGNAMES = 58
  };
  const flatbuffers::String *uniqueName() const {
    return GetPointer<const flatbuffers::String *>(VT_UNIQUENAME);
  }
  const flatbuffers::String *displayName() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAYNAME);
  }
  const TextureEffect *ambientOcclusion() const {
    return GetStruct<const TextureEffect *>(VT_AMBIENTOCCLUSION);
  }
  const flatbuffers::String *ambientOcclusionImgName() const {
    return GetPointer<const flatbuffers::String *>(VT_AMBIENTOCCLUSIONIMGNAME);
  }
  const TextureEffect *baseColor() const {
    return GetStruct<const TextureEffect *>(VT_BASECOLOR);
  }
  const flatbuffers::String *baseColorImgName() const {
    return GetPointer<const flatbuffers::String *>(VT_BASECOLORIMGNAME);
  }
  const TextureEffect *clearCoatAmt() const {
    return GetStruct<const TextureEffect *>(VT_CLEARCOATAMT);
  }
  const flatbuffers::String *clearCoatAmtImgName() const {
    return GetPointer<const flatbuffers::String *>(VT_CLEARCOATAMTIMGNAME);
  }
  const TextureEffect *clearCoatRough() const {
    return GetStruct<const TextureEffect *>(VT_CLEARCOATROUGH);
  }
  const flatbuffers::String *clearCoatRoughImgName() const {
    return GetPointer<const flatbuffers::String *>(VT_CLEARCOATROUGHIMGNAME);
  }
  const TextureEffect *bump() const {
    return GetStruct<const TextureEffect *>(VT_BUMP);
  }
  const flatbuffers::String *bumpImgName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUMPIMGNAME);
  }
  const TextureEffect *normal() const {
    return GetStruct<const TextureEffect *>(VT_NORMAL);
  }
  const flatbuffers::String *normalImgName() const {
    return GetPointer<const flatbuffers::String *>(VT_NORMALIMGNAME);
  }
  const TextureEffect *metallic() const {
    return GetStruct<const TextureEffect *>(VT_METALLIC);
  }
  const flatbuffers::String *metallicImgName() const {
    return GetPointer<const flatbuffers::String *>(VT_METALLICIMGNAME);
  }
  const TextureEffect *emissiveColor() const {
    return GetStruct<const TextureEffect *>(VT_EMISSIVECOLOR);
  }
  const flatbuffers::String *emissiveColorImgName() const {
    return GetPointer<const flatbuffers::String *>(VT_EMISSIVECOLORIMGNAME);
  }
  const TextureEffect *opacity() const {
    return GetStruct<const TextureEffect *>(VT_OPACITY);
  }
  const flatbuffers::String *opacityImgName() const {
    return GetPointer<const flatbuffers::String *>(VT_OPACITYIMGNAME);
  }
  const TextureEffect *roughness() const {
    return GetStruct<const TextureEffect *>(VT_ROUGHNESS);
  }
  const flatbuffers::String *roughnessImgName() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUGHNESSIMGNAME);
  }
  const TextureEffect *specular() const {
    return GetStruct<const TextureEffect *>(VT_SPECULAR);
  }
  const flatbuffers::String *specularImgName() const {
    return GetPointer<const flatbuffers::String *>(VT_SPECULARIMGNAME);
  }
  const TextureEffect *subsurfaceColor() const {
    return GetStruct<const TextureEffect *>(VT_SUBSURFACECOLOR);
  }
  const flatbuffers::String *subsurfaceColorImgName() const {
    return GetPointer<const flatbuffers::String *>(VT_SUBSURFACECOLORIMGNAME);
  }
  const flatbuffers::Vector<const TextureEffect *> *unknown() const {
    return GetPointer<const flatbuffers::Vector<const TextureEffect *> *>(VT_UNKNOWN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *unknownImgNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_UNKNOWNIMGNAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNIQUENAME) &&
           verifier.Verify(uniqueName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DISPLAYNAME) &&
           verifier.Verify(displayName()) &&
           VerifyField<TextureEffect>(verifier, VT_AMBIENTOCCLUSION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_AMBIENTOCCLUSIONIMGNAME) &&
           verifier.Verify(ambientOcclusionImgName()) &&
           VerifyField<TextureEffect>(verifier, VT_BASECOLOR) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BASECOLORIMGNAME) &&
           verifier.Verify(baseColorImgName()) &&
           VerifyField<TextureEffect>(verifier, VT_CLEARCOATAMT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CLEARCOATAMTIMGNAME) &&
           verifier.Verify(clearCoatAmtImgName()) &&
           VerifyField<TextureEffect>(verifier, VT_CLEARCOATROUGH) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CLEARCOATROUGHIMGNAME) &&
           verifier.Verify(clearCoatRoughImgName()) &&
           VerifyField<TextureEffect>(verifier, VT_BUMP) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BUMPIMGNAME) &&
           verifier.Verify(bumpImgName()) &&
           VerifyField<TextureEffect>(verifier, VT_NORMAL) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NORMALIMGNAME) &&
           verifier.Verify(normalImgName()) &&
           VerifyField<TextureEffect>(verifier, VT_METALLIC) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_METALLICIMGNAME) &&
           verifier.Verify(metallicImgName()) &&
           VerifyField<TextureEffect>(verifier, VT_EMISSIVECOLOR) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EMISSIVECOLORIMGNAME) &&
           verifier.Verify(emissiveColorImgName()) &&
           VerifyField<TextureEffect>(verifier, VT_OPACITY) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OPACITYIMGNAME) &&
           verifier.Verify(opacityImgName()) &&
           VerifyField<TextureEffect>(verifier, VT_ROUGHNESS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ROUGHNESSIMGNAME) &&
           verifier.Verify(roughnessImgName()) &&
           VerifyField<TextureEffect>(verifier, VT_SPECULAR) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPECULARIMGNAME) &&
           verifier.Verify(specularImgName()) &&
           VerifyField<TextureEffect>(verifier, VT_SUBSURFACECOLOR) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SUBSURFACECOLORIMGNAME) &&
           verifier.Verify(subsurfaceColorImgName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNKNOWN) &&
           verifier.Verify(unknown()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNKNOWNIMGNAMES) &&
           verifier.Verify(unknownImgNames()) &&
           verifier.VerifyVectorOfStrings(unknownImgNames()) &&
           verifier.EndTable();
  }
};

struct MaterialDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uniqueName(flatbuffers::Offset<flatbuffers::String> uniqueName) {
    fbb_.AddOffset(MaterialData::VT_UNIQUENAME, uniqueName);
  }
  void add_displayName(flatbuffers::Offset<flatbuffers::String> displayName) {
    fbb_.AddOffset(MaterialData::VT_DISPLAYNAME, displayName);
  }
  void add_ambientOcclusion(const TextureEffect *ambientOcclusion) {
    fbb_.AddStruct(MaterialData::VT_AMBIENTOCCLUSION, ambientOcclusion);
  }
  void add_ambientOcclusionImgName(flatbuffers::Offset<flatbuffers::String> ambientOcclusionImgName) {
    fbb_.AddOffset(MaterialData::VT_AMBIENTOCCLUSIONIMGNAME, ambientOcclusionImgName);
  }
  void add_baseColor(const TextureEffect *baseColor) {
    fbb_.AddStruct(MaterialData::VT_BASECOLOR, baseColor);
  }
  void add_baseColorImgName(flatbuffers::Offset<flatbuffers::String> baseColorImgName) {
    fbb_.AddOffset(MaterialData::VT_BASECOLORIMGNAME, baseColorImgName);
  }
  void add_clearCoatAmt(const TextureEffect *clearCoatAmt) {
    fbb_.AddStruct(MaterialData::VT_CLEARCOATAMT, clearCoatAmt);
  }
  void add_clearCoatAmtImgName(flatbuffers::Offset<flatbuffers::String> clearCoatAmtImgName) {
    fbb_.AddOffset(MaterialData::VT_CLEARCOATAMTIMGNAME, clearCoatAmtImgName);
  }
  void add_clearCoatRough(const TextureEffect *clearCoatRough) {
    fbb_.AddStruct(MaterialData::VT_CLEARCOATROUGH, clearCoatRough);
  }
  void add_clearCoatRoughImgName(flatbuffers::Offset<flatbuffers::String> clearCoatRoughImgName) {
    fbb_.AddOffset(MaterialData::VT_CLEARCOATROUGHIMGNAME, clearCoatRoughImgName);
  }
  void add_bump(const TextureEffect *bump) {
    fbb_.AddStruct(MaterialData::VT_BUMP, bump);
  }
  void add_bumpImgName(flatbuffers::Offset<flatbuffers::String> bumpImgName) {
    fbb_.AddOffset(MaterialData::VT_BUMPIMGNAME, bumpImgName);
  }
  void add_normal(const TextureEffect *normal) {
    fbb_.AddStruct(MaterialData::VT_NORMAL, normal);
  }
  void add_normalImgName(flatbuffers::Offset<flatbuffers::String> normalImgName) {
    fbb_.AddOffset(MaterialData::VT_NORMALIMGNAME, normalImgName);
  }
  void add_metallic(const TextureEffect *metallic) {
    fbb_.AddStruct(MaterialData::VT_METALLIC, metallic);
  }
  void add_metallicImgName(flatbuffers::Offset<flatbuffers::String> metallicImgName) {
    fbb_.AddOffset(MaterialData::VT_METALLICIMGNAME, metallicImgName);
  }
  void add_emissiveColor(const TextureEffect *emissiveColor) {
    fbb_.AddStruct(MaterialData::VT_EMISSIVECOLOR, emissiveColor);
  }
  void add_emissiveColorImgName(flatbuffers::Offset<flatbuffers::String> emissiveColorImgName) {
    fbb_.AddOffset(MaterialData::VT_EMISSIVECOLORIMGNAME, emissiveColorImgName);
  }
  void add_opacity(const TextureEffect *opacity) {
    fbb_.AddStruct(MaterialData::VT_OPACITY, opacity);
  }
  void add_opacityImgName(flatbuffers::Offset<flatbuffers::String> opacityImgName) {
    fbb_.AddOffset(MaterialData::VT_OPACITYIMGNAME, opacityImgName);
  }
  void add_roughness(const TextureEffect *roughness) {
    fbb_.AddStruct(MaterialData::VT_ROUGHNESS, roughness);
  }
  void add_roughnessImgName(flatbuffers::Offset<flatbuffers::String> roughnessImgName) {
    fbb_.AddOffset(MaterialData::VT_ROUGHNESSIMGNAME, roughnessImgName);
  }
  void add_specular(const TextureEffect *specular) {
    fbb_.AddStruct(MaterialData::VT_SPECULAR, specular);
  }
  void add_specularImgName(flatbuffers::Offset<flatbuffers::String> specularImgName) {
    fbb_.AddOffset(MaterialData::VT_SPECULARIMGNAME, specularImgName);
  }
  void add_subsurfaceColor(const TextureEffect *subsurfaceColor) {
    fbb_.AddStruct(MaterialData::VT_SUBSURFACECOLOR, subsurfaceColor);
  }
  void add_subsurfaceColorImgName(flatbuffers::Offset<flatbuffers::String> subsurfaceColorImgName) {
    fbb_.AddOffset(MaterialData::VT_SUBSURFACECOLORIMGNAME, subsurfaceColorImgName);
  }
  void add_unknown(flatbuffers::Offset<flatbuffers::Vector<const TextureEffect *>> unknown) {
    fbb_.AddOffset(MaterialData::VT_UNKNOWN, unknown);
  }
  void add_unknownImgNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> unknownImgNames) {
    fbb_.AddOffset(MaterialData::VT_UNKNOWNIMGNAMES, unknownImgNames);
  }
  MaterialDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialDataBuilder &operator=(const MaterialDataBuilder &);
  flatbuffers::Offset<MaterialData> Finish() {
    const auto end = fbb_.EndTable(start_, 28);
    auto o = flatbuffers::Offset<MaterialData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaterialData> CreateMaterialData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uniqueName = 0,
    flatbuffers::Offset<flatbuffers::String> displayName = 0,
    const TextureEffect *ambientOcclusion = 0,
    flatbuffers::Offset<flatbuffers::String> ambientOcclusionImgName = 0,
    const TextureEffect *baseColor = 0,
    flatbuffers::Offset<flatbuffers::String> baseColorImgName = 0,
    const TextureEffect *clearCoatAmt = 0,
    flatbuffers::Offset<flatbuffers::String> clearCoatAmtImgName = 0,
    const TextureEffect *clearCoatRough = 0,
    flatbuffers::Offset<flatbuffers::String> clearCoatRoughImgName = 0,
    const TextureEffect *bump = 0,
    flatbuffers::Offset<flatbuffers::String> bumpImgName = 0,
    const TextureEffect *normal = 0,
    flatbuffers::Offset<flatbuffers::String> normalImgName = 0,
    const TextureEffect *metallic = 0,
    flatbuffers::Offset<flatbuffers::String> metallicImgName = 0,
    const TextureEffect *emissiveColor = 0,
    flatbuffers::Offset<flatbuffers::String> emissiveColorImgName = 0,
    const TextureEffect *opacity = 0,
    flatbuffers::Offset<flatbuffers::String> opacityImgName = 0,
    const TextureEffect *roughness = 0,
    flatbuffers::Offset<flatbuffers::String> roughnessImgName = 0,
    const TextureEffect *specular = 0,
    flatbuffers::Offset<flatbuffers::String> specularImgName = 0,
    const TextureEffect *subsurfaceColor = 0,
    flatbuffers::Offset<flatbuffers::String> subsurfaceColorImgName = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TextureEffect *>> unknown = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> unknownImgNames = 0) {
  MaterialDataBuilder builder_(_fbb);
  builder_.add_unknownImgNames(unknownImgNames);
  builder_.add_unknown(unknown);
  builder_.add_subsurfaceColorImgName(subsurfaceColorImgName);
  builder_.add_subsurfaceColor(subsurfaceColor);
  builder_.add_specularImgName(specularImgName);
  builder_.add_specular(specular);
  builder_.add_roughnessImgName(roughnessImgName);
  builder_.add_roughness(roughness);
  builder_.add_opacityImgName(opacityImgName);
  builder_.add_opacity(opacity);
  builder_.add_emissiveColorImgName(emissiveColorImgName);
  builder_.add_emissiveColor(emissiveColor);
  builder_.add_metallicImgName(metallicImgName);
  builder_.add_metallic(metallic);
  builder_.add_normalImgName(normalImgName);
  builder_.add_normal(normal);
  builder_.add_bumpImgName(bumpImgName);
  builder_.add_bump(bump);
  builder_.add_clearCoatRoughImgName(clearCoatRoughImgName);
  builder_.add_clearCoatRough(clearCoatRough);
  builder_.add_clearCoatAmtImgName(clearCoatAmtImgName);
  builder_.add_clearCoatAmt(clearCoatAmt);
  builder_.add_baseColorImgName(baseColorImgName);
  builder_.add_baseColor(baseColor);
  builder_.add_ambientOcclusionImgName(ambientOcclusionImgName);
  builder_.add_ambientOcclusion(ambientOcclusion);
  builder_.add_displayName(displayName);
  builder_.add_uniqueName(uniqueName);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaterialData> CreateMaterialDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uniqueName = nullptr,
    const char *displayName = nullptr,
    const TextureEffect *ambientOcclusion = 0,
    const char *ambientOcclusionImgName = nullptr,
    const TextureEffect *baseColor = 0,
    const char *baseColorImgName = nullptr,
    const TextureEffect *clearCoatAmt = 0,
    const char *clearCoatAmtImgName = nullptr,
    const TextureEffect *clearCoatRough = 0,
    const char *clearCoatRoughImgName = nullptr,
    const TextureEffect *bump = 0,
    const char *bumpImgName = nullptr,
    const TextureEffect *normal = 0,
    const char *normalImgName = nullptr,
    const TextureEffect *metallic = 0,
    const char *metallicImgName = nullptr,
    const TextureEffect *emissiveColor = 0,
    const char *emissiveColorImgName = nullptr,
    const TextureEffect *opacity = 0,
    const char *opacityImgName = nullptr,
    const TextureEffect *roughness = 0,
    const char *roughnessImgName = nullptr,
    const TextureEffect *specular = 0,
    const char *specularImgName = nullptr,
    const TextureEffect *subsurfaceColor = 0,
    const char *subsurfaceColorImgName = nullptr,
    const std::vector<const TextureEffect *> *unknown = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *unknownImgNames = nullptr) {
  return Foundry::CreateMaterialData(
      _fbb,
      uniqueName ? _fbb.CreateString(uniqueName) : 0,
      displayName ? _fbb.CreateString(displayName) : 0,
      ambientOcclusion,
      ambientOcclusionImgName ? _fbb.CreateString(ambientOcclusionImgName) : 0,
      baseColor,
      baseColorImgName ? _fbb.CreateString(baseColorImgName) : 0,
      clearCoatAmt,
      clearCoatAmtImgName ? _fbb.CreateString(clearCoatAmtImgName) : 0,
      clearCoatRough,
      clearCoatRoughImgName ? _fbb.CreateString(clearCoatRoughImgName) : 0,
      bump,
      bumpImgName ? _fbb.CreateString(bumpImgName) : 0,
      normal,
      normalImgName ? _fbb.CreateString(normalImgName) : 0,
      metallic,
      metallicImgName ? _fbb.CreateString(metallicImgName) : 0,
      emissiveColor,
      emissiveColorImgName ? _fbb.CreateString(emissiveColorImgName) : 0,
      opacity,
      opacityImgName ? _fbb.CreateString(opacityImgName) : 0,
      roughness,
      roughnessImgName ? _fbb.CreateString(roughnessImgName) : 0,
      specular,
      specularImgName ? _fbb.CreateString(specularImgName) : 0,
      subsurfaceColor,
      subsurfaceColorImgName ? _fbb.CreateString(subsurfaceColorImgName) : 0,
      unknown ? _fbb.CreateVector<const TextureEffect *>(*unknown) : 0,
      unknownImgNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*unknownImgNames) : 0);
}

struct ConfigData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACTORUNIQUENAMEIDENT = 4,
    VT_ASSETUNIQUENAMEIDENT = 6,
    VT_USESUBFOLDER = 8
  };
  bool actorUniqueNameIdent() const {
    return GetField<uint8_t>(VT_ACTORUNIQUENAMEIDENT, 0) != 0;
  }
  bool assetUniqueNameIdent() const {
    return GetField<uint8_t>(VT_ASSETUNIQUENAMEIDENT, 0) != 0;
  }
  bool useSubFolder() const {
    return GetField<uint8_t>(VT_USESUBFOLDER, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACTORUNIQUENAMEIDENT) &&
           VerifyField<uint8_t>(verifier, VT_ASSETUNIQUENAMEIDENT) &&
           VerifyField<uint8_t>(verifier, VT_USESUBFOLDER) &&
           verifier.EndTable();
  }
};

struct ConfigDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUniqueNameIdent(bool actorUniqueNameIdent) {
    fbb_.AddElement<uint8_t>(ConfigData::VT_ACTORUNIQUENAMEIDENT, static_cast<uint8_t>(actorUniqueNameIdent), 0);
  }
  void add_assetUniqueNameIdent(bool assetUniqueNameIdent) {
    fbb_.AddElement<uint8_t>(ConfigData::VT_ASSETUNIQUENAMEIDENT, static_cast<uint8_t>(assetUniqueNameIdent), 0);
  }
  void add_useSubFolder(bool useSubFolder) {
    fbb_.AddElement<uint8_t>(ConfigData::VT_USESUBFOLDER, static_cast<uint8_t>(useSubFolder), 0);
  }
  ConfigDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConfigDataBuilder &operator=(const ConfigDataBuilder &);
  flatbuffers::Offset<ConfigData> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<ConfigData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConfigData> CreateConfigData(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool actorUniqueNameIdent = false,
    bool assetUniqueNameIdent = false,
    bool useSubFolder = false) {
  ConfigDataBuilder builder_(_fbb);
  builder_.add_useSubFolder(useSubFolder);
  builder_.add_assetUniqueNameIdent(assetUniqueNameIdent);
  builder_.add_actorUniqueNameIdent(actorUniqueNameIdent);
  return builder_.Finish();
}

}  // namespace Foundry

#endif  // FLATBUFFERS_GENERATED_NEUTRALDATA_FOUNDRY_H_
